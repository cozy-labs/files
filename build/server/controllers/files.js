// Generated by CoffeeScript 1.7.1
var File, Folder, async, feed, folderParent, fs, getFileClass, log, mime, moment, multiparty, normalizePath, pathHelpers, processAttachment, resetTimeout, sharing, timeout, updateParents, _ref;

fs = require('fs');

async = require('async');

moment = require('moment');

multiparty = require('multiparty');

mime = require('mime');

log = require('printit')({
  prefix: 'files'
});

File = require('../models/file');

Folder = require('../models/folder');

feed = require('../lib/feed');

sharing = require('../helpers/sharing');

pathHelpers = require('../helpers/path');

_ref = require('../helpers/file'), normalizePath = _ref.normalizePath, processAttachment = _ref.processAttachment, getFileClass = _ref.getFileClass;

module.exports.fetch = function(req, res, next, id) {
  return File.request('all', {
    key: id
  }, function(err, file) {
    if (err || !file || file.length === 0) {
      if (err == null) {
        err = new Error('File not found');
        err.status = 404;
        err.template = {
          name: '404',
          params: {
            localization: require('../lib/localization_manager'),
            isPublic: req.url.indexOf('public') !== -1
          }
        };
      }
      return next(err);
    } else {
      req.file = file[0];
      return next();
    }
  });
};

module.exports.find = function(req, res) {
  return res.send(req.file);
};

module.exports.all = function(req, res, next) {
  return File.all(function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  });
};

folderParent = {};

timeout = null;

module.exports.create = function(req, res, next) {
  var fields, form;
  if (timeout != null) {
    clearTimeout(timeout);
  }
  fields = {};
  form = new multiparty.Form();
  form.on('part', function(part) {
    var err, fullPath, name, path;
    if (part.filename == null) {
      fields[part.name] = '';
      return part.on('data', function(buffer) {
        return fields[part.name] = buffer.toString();
      });
    } else {
      name = fields.name;
      path = fields.path;
      if (!name || name === "") {
        err = new Error("Invalid arguments: no name given");
        err.status = 400;
        return next(err);
      } else {
        path = normalizePath(path);
        fullPath = "" + path + "/" + name;
        return File.byFullPath({
          key: fullPath
        }, (function(_this) {
          return function(err, sameFiles) {
            var createFile, data, fileClass, now, upload;
            if (err) {
              return next(err);
            }
            if (sameFiles.length > 0) {
              return res.send({
                error: true,
                code: 'EEXISTS',
                msg: "This file already exists"
              }, 400);
            } else {
              now = moment().toISOString();
              fileClass = getFileClass(part);
              data = {
                name: name,
                path: normalizePath(path),
                creationDate: now,
                lastModification: now,
                mime: mime.lookup(name),
                size: part.byteCount,
                tags: [],
                "class": fileClass
              };
              upload = true;
              createFile = function() {
                var attachBinary, index, keepAlive;
                keepAlive = function() {
                  if (upload) {
                    feed.publish('usage.application', 'files');
                    setTimeout(function() {
                      return keepAlive();
                    }, 60 * 1000);
                    return resetTimeout();
                  }
                };
                attachBinary = function(newFile) {
                  var isStorageError;
                  isStorageError = function(err) {
                    var stringErr;
                    stringErr = err.toString();
                    return stringErr.indexOf('enough storage');
                  };
                  part.path = data.name;
                  data = {
                    "name": "file"
                  };
                  return newFile.attachBinary(part, data, function(err) {
                    upload = false;
                    if (err) {
                      return newFile.destroy(function(error) {
                        if (isStorageError(error) !== -1) {
                          return res.send({
                            error: true,
                            code: 'ESTORAGE',
                            msg: "modal error size"
                          }, 400);
                        } else {
                          return next(err);
                        }
                      });
                    } else {
                      return index(newFile);
                    }
                  });
                };
                index = function(newFile) {
                  return newFile.index(["name"], function(err) {
                    var who;
                    if (err) {
                      log.debug(err);
                    }
                    who = req.guestEmail || 'owner';
                    return sharing.notifyChanges(who, newFile, function(err) {
                      if (err) {
                        log.debug(err);
                      }
                      return res.send(newFile, 200);
                    });
                  });
                };
                return File.create(data, function(err, newFile) {
                  if (err) {
                    return next(err);
                  } else {
                    attachBinary(newFile);
                    return keepAlive();
                  }
                });
              };
              return Folder.byFullPath({
                key: data.path
              }, function(err, parents) {
                var parent;
                if (err) {
                  return next(err);
                }
                if (parents.length > 0) {
                  parent = parents[0];
                  data.tags = parent.tags;
                  parent.lastModification = now;
                  folderParent[parent.name] = parent;
                  return createFile();
                } else {
                  return createFile();
                }
              });
            }
          };
        })(this));
      }
    }
  });
  form.on('error', function(err) {
    return log.error(err);
  });
  return form.parse(req);
};

resetTimeout = (function(_this) {
  return function() {
    if (timeout != null) {
      clearTimeout(timeout);
    }
    return timeout = setTimeout(function() {
      return updateParents();
    }, 60 * 1000);
  };
})(this);

updateParents = function() {
  var errors, folder, name, _i, _len, _ref1;
  errors = {};
  _ref1 = Object.keys(folderParent);
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    name = _ref1[_i];
    folder = folderParent[name];
    folder.save(function(err) {
      if (err != null) {
        return errors[folder.name] = err;
      }
    });
  }
  return folderParent = {};
};

module.exports.modify = function(req, res, next) {
  var body, file, isPublic, newFullPath, newName, newPath, previousFullPath, previousName, previousPath, tags, _ref1, _ref2;
  log.info("File modification of " + req.file.name + "...");
  file = req.file;
  body = req.body;
  if (body.tags && (Array.isArray(body.tags)) && ((_ref1 = file.tags) != null ? _ref1.toString() : void 0) !== ((_ref2 = body.tags) != null ? _ref2.toString() : void 0)) {
    tags = body.tags;
    tags = tags.filter(function(tag) {
      return typeof tag === 'string';
    });
    return file.updateAttributes({
      tags: tags
    }, (function(_this) {
      return function(err) {
        if (err) {
          return next(new Error("Cannot change tags: " + err));
        } else {
          log.info("Tags changed for " + file.name + ": " + tags);
          return res.send({
            success: 'Tags successfully changed'
          }, 200);
        }
      };
    })(this));
  } else if ((!body.name || body.name === "") && (body.path == null)) {
    log.info("No arguments, no modification performed for " + req.file.name);
    return next(new Error("Invalid arguments, name should be specified."));
  } else {
    previousName = file.name;
    newName = body.name != null ? body.name : previousName;
    previousPath = file.path;
    if (req.body.path != null) {
      body.path = normalizePath(body.path);
    }
    newPath = body.path != null ? body.path : previousPath;
    isPublic = body["public"];
    newFullPath = "" + newPath + "/" + newName;
    previousFullPath = "" + previousPath + "/" + previousName;
    return File.byFullPath({
      key: newFullPath
    }, function(err, sameFiles) {
      var data, modificationSuccess;
      if (err) {
        return next(err);
      }
      modificationSuccess = function(err) {
        if (err) {
          log.raw(err);
        }
        log.info(("Filechanged from " + previousFullPath + " ") + ("to " + newFullPath));
        return res.send({
          success: 'File successfully modified'
        });
      };
      if (sameFiles.length > 0) {
        log.info("No modification: Name " + newName + " already exists.");
        return res.send(400, {
          error: true,
          msg: "The name is already in use."
        });
      } else {
        data = {
          name: newName,
          path: normalizePath(newPath),
          "public": isPublic,
          lastModification: moment().toISOString()
        };
        if (body.clearance) {
          data.clearance = body.clearance;
        }
        return file.updateAttributes(data, (function(_this) {
          return function(err) {
            if (err) {
              return next(new Error('Cannot modify file'));
            } else {
              return file.updateParentModifDate(function(err) {
                if (err) {
                  log.raw(err);
                }
                return file.index(["name"], modificationSuccess);
              });
            }
          };
        })(this));
      }
    });
  }
};

module.exports.destroy = function(req, res, next) {
  var file;
  file = req.file;
  return file.destroyWithBinary(function(err) {
    if (err) {
      log.error("Cannot destroy document " + file.id);
      return next(err);
    } else {
      return file.updateParentModifDate(function(err) {
        if (err) {
          log.raw(err);
        }
        return res.send({
          success: 'File successfully deleted'
        });
      });
    }
  });
};

module.exports.getAttachment = function(req, res, next) {
  return processAttachment(req, res, next, false);
};

module.exports.downloadAttachment = function(req, res, next) {
  return processAttachment(req, res, next, true);
};

module.exports.search = function(req, res, next) {
  var parts, query, sendResults, tag;
  sendResults = function(err, files) {
    if (err) {
      return next(err);
    } else {
      return res.send(files);
    }
  };
  query = req.body.id;
  query = query.trim();
  if (query.indexOf('tag:') !== -1) {
    parts = query.split();
    parts = parts.filter(function(tag) {
      return tag.indexOf('tag:' !== -1);
    });
    tag = parts[0].split('tag:')[1];
    return File.request('byTag', {
      key: tag
    }, sendResults);
  } else {
    return File.search("*" + query + "*", sendResults);
  }
};
